#!/usr/bin/env ruby
# encoding: UTF-8
$:.unshift(File.dirname(File.expand_path('../../lib/blue_hydra.rb',__FILE__)))

require 'optparse'
require 'blue_hydra'
STDIN.sync = true

options = {}

OptionParser.new do |opts|
  opts.on("-d", "--daemonize", "Suppress output and run in daemon mode") do |v|
    options[:daemonize] = true
  end
  opts.on("-n", "--nopulse", "Do not send results to hermes") do |v|
    options[:nopulse] = true
  end
end.parse!

if options[:daemonize]
  BlueHydra.daemon_mode = true
end

if options[:nopulse]
  BlueHydra.no_pulse = true
end

# This file is used by the service scan to kill the process and should be
# cleaned up when this crashes or is killed via the service scan. 
PID_FILE = '/var/run/blue_hydra.pid'
File.write(PID_FILE, Process.pid)

done = false
trap('SIGINT') do
  done = true
end

begin
  # Start the main workers...
  runner = BlueHydra::Runner.new
  runner.start

  # This blocking loop keeps the scanner alive in its threads. Refer to the
  # BlueHydra::Runner to understand the main work threads.
  loop do 

    if done
      BlueHydra.logger.info("BlueHydra Killed! Exiting... SIGINT")
      exit_status = 0
      break
    end

    status = runner.status

    keys = [ :btmon_thread, :chunker_thread, :parser_thread, :result_thread ]

    unless BlueHydra.config[:file]
      keys << :discovery_thread
    end

    keys.each do |thread_key|
      if status[thread_key] == nil || status[thread_key] == false
        raise FailedThreadError, thread_key
      end
    end

    sleep 1 unless done
  end

rescue FailedThreadError => e
  BlueHydra.logger.error("Thread failure: #{e.message}")
  exit_status = 1

rescue => e
  BlueHydra.logger.error("Generic Error: #{e.to_s}") 
  e.backtrace.each do |line|
    BlueHydra.logger.error(line) 
  end
  exit_status = 1

ensure
  runner.stop
  File.unlink(PID_FILE)
  BlueHydra.logger.warn("GOODBYE! ^_^")
  exit_status ||= 7
  exit exit_status
end
